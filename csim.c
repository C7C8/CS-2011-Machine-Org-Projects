//crmyers (Christopher Myers) 2017

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "cachelab.h"

/*
 * *****************
 * ATTENTION GRADER!
 * *****************
 *
 * I apologize for the mess below, it isn't mine. Everything from here to line 910 is AUTOGENERATED by the GNU utility
 * gengetopt; it saved me from spending more time on options parsing than on cache writing. For the file that made
 * gengetopt create this abomination, see file "options.ggo". Otherwise, just skip straight to line 910 to see the code
 * I actually wrote. The GNU code is here and not in separate files so that the autograder could still compile my code.
 *
 * TL;DR SKIP TO LINE 910 TO SEE MY ACTUAL WORK!
 */

/** @file cmdline.h
 *  @brief The header file for the command line option parser
 *  generated by GNU Gengetopt version 2.22.6
 *  http://www.gnu.org/software/gengetopt.
 *  DO NOT modify this file, since it can be overwritten
 *  @author GNU Gengetopt by Lorenzo Bettini */

#ifndef CMDLINE_H
#define CMDLINE_H

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h> /* for FILE */

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifndef CMDLINE_PARSER_PACKAGE
/** @brief the program name (used for printing errors) */
#define CMDLINE_PARSER_PACKAGE "crmyers-cachelab"
#endif

#ifndef CMDLINE_PARSER_PACKAGE_NAME
/** @brief the complete program name (used for help and version) */
#define CMDLINE_PARSER_PACKAGE_NAME "crmyers-cachelab"
#endif

#ifndef CMDLINE_PARSER_VERSION
/** @brief the program version */
#define CMDLINE_PARSER_VERSION "1.0"
#endif

/** @brief Where the command line options are stored */
struct gengetopt_args_info
{
  const char *help_help; /**< @brief Print help and exit help description.  */
  const char *detailed_help_help; /**< @brief Print help, including all details and hidden options, and exit help description.  */
  const char *version_help; /**< @brief Print version and exit help description.  */
  const char *verbose_help; /**< @brief Print trace info help description.  */
  int set_index_bits_arg;	/**< @brief Number of set index bits.  */
  char * set_index_bits_orig;	/**< @brief Number of set index bits original value given at command line.  */
  const char *set_index_bits_help; /**< @brief Number of set index bits help description.  */
  int associativity_arg;	/**< @brief Number of lines per set.  */
  char * associativity_orig;	/**< @brief Number of lines per set original value given at command line.  */
  const char *associativity_help; /**< @brief Number of lines per set help description.  */
  int block_bits_arg;	/**< @brief Number of block bits.  */
  char * block_bits_orig;	/**< @brief Number of block bits original value given at command line.  */
  const char *block_bits_help; /**< @brief Number of block bits help description.  */
  char * tracefile_arg;	/**< @brief Tracefile as generated by valgrind.  */
  char * tracefile_orig;	/**< @brief Tracefile as generated by valgrind original value given at command line.  */
  const char *tracefile_help; /**< @brief Tracefile as generated by valgrind help description.  */

  unsigned int help_given ;	/**< @brief Whether help was given.  */
  unsigned int detailed_help_given ;	/**< @brief Whether detailed-help was given.  */
  unsigned int version_given ;	/**< @brief Whether version was given.  */
  unsigned int verbose_given ;	/**< @brief Whether verbose was given.  */
  unsigned int set_index_bits_given ;	/**< @brief Whether set-index-bits was given.  */
  unsigned int associativity_given ;	/**< @brief Whether associativity was given.  */
  unsigned int block_bits_given ;	/**< @brief Whether block-bits was given.  */
  unsigned int tracefile_given ;	/**< @brief Whether tracefile was given.  */

} ;

/** @brief The additional parameters to pass to parser functions */
struct cmdline_parser_params
{
  int override; /**< @brief whether to override possibly already present options (default 0) */
  int initialize; /**< @brief whether to initialize the option structure gengetopt_args_info (default 1) */
  int check_required; /**< @brief whether to check that all required options were provided (default 1) */
  int check_ambiguity; /**< @brief whether to check for options already specified in the option structure gengetopt_args_info (default 0) */
  int print_errors; /**< @brief whether getopt_long should print an error message for a bad option (default 1) */
} ;

/** @brief the purpose string of the program */
extern const char *gengetopt_args_info_purpose;
/** @brief the usage string of the program */
extern const char *gengetopt_args_info_usage;
/** @brief the description string of the program */
extern const char *gengetopt_args_info_description;
/** @brief all the lines making the help output */
extern const char *gengetopt_args_info_help[];
/** @brief all the lines making the detailed help output (including hidden options and details) */
extern const char *gengetopt_args_info_detailed_help[];

/**
 * The command line parser
 * @param argc the number of command line options
 * @param argv the command line options
 * @param args_info the structure where option information will be stored
 * @return 0 if everything went fine, NON 0 if an error took place
 */
int cmdline_parser (int argc, char **argv,
  struct gengetopt_args_info *args_info);

/**
 * The command line parser (version with additional parameters - deprecated)
 * @param argc the number of command line options
 * @param argv the command line options
 * @param args_info the structure where option information will be stored
 * @param override whether to override possibly already present options
 * @param initialize whether to initialize the option structure my_args_info
 * @param check_required whether to check that all required options were provided
 * @return 0 if everything went fine, NON 0 if an error took place
 * @deprecated use cmdline_parser_ext() instead
 */
int cmdline_parser2 (int argc, char **argv,
  struct gengetopt_args_info *args_info,
  int override, int initialize, int check_required);

/**
 * The command line parser (version with additional parameters)
 * @param argc the number of command line options
 * @param argv the command line options
 * @param args_info the structure where option information will be stored
 * @param params additional parameters for the parser
 * @return 0 if everything went fine, NON 0 if an error took place
 */
int cmdline_parser_ext (int argc, char **argv,
  struct gengetopt_args_info *args_info,
  struct cmdline_parser_params *params);

/**
 * Save the contents of the option struct into an already open FILE stream.
 * @param outfile the stream where to dump options
 * @param args_info the option struct to dump
 * @return 0 if everything went fine, NON 0 if an error took place
 */
int cmdline_parser_dump(FILE *outfile,
  struct gengetopt_args_info *args_info);

/**
 * Save the contents of the option struct into a (text) file.
 * This file can be read by the config file parser (if generated by gengetopt)
 * @param filename the file where to save
 * @param args_info the option struct to save
 * @return 0 if everything went fine, NON 0 if an error took place
 */
int cmdline_parser_file_save(const char *filename,
  struct gengetopt_args_info *args_info);

/**
 * Print the help
 */
void cmdline_parser_print_help(void);
/**
 * Print the detailed help (including hidden options and details)
 */
void cmdline_parser_print_detailed_help(void);
/**
 * Print the version
 */
void cmdline_parser_print_version(void);

/**
 * Initializes all the fields a cmdline_parser_params structure
 * to their default values
 * @param params the structure to initialize
 */
void cmdline_parser_params_init(struct cmdline_parser_params *params);

/**
 * Allocates dynamically a cmdline_parser_params structure and initializes
 * all its fields to their default values
 * @return the created and initialized cmdline_parser_params structure
 */
struct cmdline_parser_params *cmdline_parser_params_create(void);

/**
 * Initializes the passed gengetopt_args_info structure's fields
 * (also set default values for options that have a default)
 * @param args_info the structure to initialize
 */
void cmdline_parser_init (struct gengetopt_args_info *args_info);
/**
 * Deallocates the string fields of the gengetopt_args_info structure
 * (but does not deallocate the structure itself)
 * @param args_info the structure to deallocate
 */
void cmdline_parser_free (struct gengetopt_args_info *args_info);

/**
 * Checks that all the required options were specified
 * @param args_info the structure to check
 * @param prog_name the name of the program that will be used to print
 *   possible errors
 * @return
 */
int cmdline_parser_required (struct gengetopt_args_info *args_info,
  const char *prog_name);


#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* CMDLINE_H */

/*
  File autogenerated by gengetopt version 2.22.6
  generated with the following command:
  gengetopt

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif

#include <getopt.h>

const char *gengetopt_args_info_purpose = "Simulate a cache";

const char *gengetopt_args_info_usage = "Usage: csim [-hv] -s <s> -E <E> -b <b> -t <tracefile>";

const char *gengetopt_args_info_versiontext = "Created by crmyers for d17-cs2011 at WPI";

const char *gengetopt_args_info_description = "Simulate a cache using s set index bits, E lines per set, b block bits, and a\ntracefile as input. If no tracefile is specified, stdin is used as an input.\nThe tracefile should be generated by valgrind (see below for more details); any\ninstruction loads are ignored.";

const char *gengetopt_args_info_detailed_help[] = {
		"  -h, --help                Print help and exit",
		"      --detailed-help       Print help, including all details and hidden\n                              options, and exit",
		"  -V, --version             Print version and exit",
		"  -v, --verbose             Print trace info",
		"  -s, --set-index-bits=INT  Number of set index bits",
		"  Set the number of set index bits, where the number of sets is 2^s",
		"  -E, --associativity=INT   Number of lines per set",
		"  -b, --block-bits=INT      Number of block bits",
		"  Set the number of block bits, where the block size is 2^b",
		"  -t, --tracefile=STRING    Tracefile as generated by valgrind",
		"  Tracefile as generated by valgrind using something like `valgrind --log-fd=1\n  --tool=lackey -v --trace-mem=yes` on an executable.",
		0
};

static void
init_help_array(void)
{
	gengetopt_args_info_help[0] = gengetopt_args_info_detailed_help[0];
	gengetopt_args_info_help[1] = gengetopt_args_info_detailed_help[1];
	gengetopt_args_info_help[2] = gengetopt_args_info_detailed_help[2];
	gengetopt_args_info_help[3] = gengetopt_args_info_detailed_help[3];
	gengetopt_args_info_help[4] = gengetopt_args_info_detailed_help[4];
	gengetopt_args_info_help[5] = gengetopt_args_info_detailed_help[6];
	gengetopt_args_info_help[6] = gengetopt_args_info_detailed_help[7];
	gengetopt_args_info_help[7] = gengetopt_args_info_detailed_help[9];
	gengetopt_args_info_help[8] = 0;

}

const char *gengetopt_args_info_help[9];

typedef enum {ARG_NO
	, ARG_STRING
	, ARG_INT
} cmdline_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
						 struct cmdline_parser_params *params, const char *additional_error);

static int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
	args_info->help_given = 0 ;
	args_info->detailed_help_given = 0 ;
	args_info->version_given = 0 ;
	args_info->verbose_given = 0 ;
	args_info->set_index_bits_given = 0 ;
	args_info->associativity_given = 0 ;
	args_info->block_bits_given = 0 ;
	args_info->tracefile_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
	FIX_UNUSED (args_info);
	args_info->set_index_bits_orig = NULL;
	args_info->associativity_orig = NULL;
	args_info->block_bits_orig = NULL;
	args_info->tracefile_arg = NULL;
	args_info->tracefile_orig = NULL;

}

static
void init_args_info(struct gengetopt_args_info *args_info)
{

	init_help_array();
	args_info->help_help = gengetopt_args_info_detailed_help[0] ;
	args_info->detailed_help_help = gengetopt_args_info_detailed_help[1] ;
	args_info->version_help = gengetopt_args_info_detailed_help[2] ;
	args_info->verbose_help = gengetopt_args_info_detailed_help[3] ;
	args_info->set_index_bits_help = gengetopt_args_info_detailed_help[4] ;
	args_info->associativity_help = gengetopt_args_info_detailed_help[6] ;
	args_info->block_bits_help = gengetopt_args_info_detailed_help[7] ;
	args_info->tracefile_help = gengetopt_args_info_detailed_help[9] ;

}

void
cmdline_parser_print_version (void)
{
	printf ("%s %s\n",
			(strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),
			CMDLINE_PARSER_VERSION);

	if (strlen(gengetopt_args_info_versiontext) > 0)
		printf("\n%s\n", gengetopt_args_info_versiontext);
}

static void print_help_common(void) {
	cmdline_parser_print_version ();

	if (strlen(gengetopt_args_info_purpose) > 0)
		printf("\n%s\n", gengetopt_args_info_purpose);

	if (strlen(gengetopt_args_info_usage) > 0)
		printf("\n%s\n", gengetopt_args_info_usage);

	printf("\n");

	if (strlen(gengetopt_args_info_description) > 0)
		printf("%s\n\n", gengetopt_args_info_description);
}

void
cmdline_parser_print_help (void)
{
	int i = 0;
	print_help_common();
	while (gengetopt_args_info_help[i])
		printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_print_detailed_help (void)
{
	int i = 0;
	print_help_common();
	while (gengetopt_args_info_detailed_help[i])
		printf("%s\n", gengetopt_args_info_detailed_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
	clear_given (args_info);
	clear_args (args_info);
	init_args_info (args_info);
}

void
cmdline_parser_params_init(struct cmdline_parser_params *params)
{
	if (params)
	{
		params->override = 0;
		params->initialize = 1;
		params->check_required = 1;
		params->check_ambiguity = 0;
		params->print_errors = 1;
	}
}

struct cmdline_parser_params *
cmdline_parser_params_create(void)
{
	struct cmdline_parser_params *params =
			(struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
	cmdline_parser_params_init(params);
	return params;
}

static void
free_string_field (char **s)
{
	if (*s)
	{
		free (*s);
		*s = 0;
	}
}


static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{

	free_string_field (&(args_info->set_index_bits_orig));
	free_string_field (&(args_info->associativity_orig));
	free_string_field (&(args_info->block_bits_orig));
	free_string_field (&(args_info->tracefile_arg));
	free_string_field (&(args_info->tracefile_orig));



	clear_given (args_info);
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
	FIX_UNUSED (values);
	if (arg) {
		fprintf(outfile, "%s=\"%s\"\n", opt, arg);
	} else {
		fprintf(outfile, "%s\n", opt);
	}
}


int
cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
	int i = 0;

	if (!outfile)
	{
		fprintf (stderr, "%s: cannot dump options to stream\n", CMDLINE_PARSER_PACKAGE);
		return EXIT_FAILURE;
	}

	if (args_info->help_given)
		write_into_file(outfile, "help", 0, 0 );
	if (args_info->detailed_help_given)
		write_into_file(outfile, "detailed-help", 0, 0 );
	if (args_info->version_given)
		write_into_file(outfile, "version", 0, 0 );
	if (args_info->verbose_given)
		write_into_file(outfile, "verbose", 0, 0 );
	if (args_info->set_index_bits_given)
		write_into_file(outfile, "set-index-bits", args_info->set_index_bits_orig, 0);
	if (args_info->associativity_given)
		write_into_file(outfile, "associativity", args_info->associativity_orig, 0);
	if (args_info->block_bits_given)
		write_into_file(outfile, "block-bits", args_info->block_bits_orig, 0);
	if (args_info->tracefile_given)
		write_into_file(outfile, "tracefile", args_info->tracefile_orig, 0);


	i = EXIT_SUCCESS;
	return i;
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
	FILE *outfile;
	int i = 0;

	outfile = fopen(filename, "w");

	if (!outfile)
	{
		fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
		return EXIT_FAILURE;
	}

	i = cmdline_parser_dump(outfile, args_info);
	fclose (outfile);

	return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
	cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
	char *result = 0;
	if (!s)
		return result;

	result = (char*)malloc(strlen(s) + 1);
	if (result == (char*)0)
		return (char*)0;
	strcpy(result, s);
	return result;
}

int
cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
{
	return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
					struct cmdline_parser_params *params)
{
	int result;
	result = cmdline_parser_internal (argc, argv, args_info, params, 0);

	if (result == EXIT_FAILURE)
	{
		cmdline_parser_free (args_info);
		exit (EXIT_FAILURE);
	}

	return result;
}

int
cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
	int result;
	struct cmdline_parser_params params;

	params.override = override;
	params.initialize = initialize;
	params.check_required = check_required;
	params.check_ambiguity = 0;
	params.print_errors = 1;

	result = cmdline_parser_internal (argc, argv, args_info, &params, 0);

	if (result == EXIT_FAILURE)
	{
		cmdline_parser_free (args_info);
		exit (EXIT_FAILURE);
	}

	return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
	int result = EXIT_SUCCESS;

	if (cmdline_parser_required2(args_info, prog_name, 0) > 0)
		result = EXIT_FAILURE;

	if (result == EXIT_FAILURE)
	{
		cmdline_parser_free (args_info);
		exit (EXIT_FAILURE);
	}

	return result;
}

int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
{
	int error_occurred = 0;
	FIX_UNUSED (additional_error);

	/* checks for required options */
	if (! args_info->set_index_bits_given)
	{
		fprintf (stderr, "%s: '--set-index-bits' ('-s') option required%s\n", prog_name, (additional_error ? additional_error : ""));
		error_occurred = 1;
	}

	if (! args_info->associativity_given)
	{
		fprintf (stderr, "%s: '--associativity' ('-E') option required%s\n", prog_name, (additional_error ? additional_error : ""));
		error_occurred = 1;
	}

	if (! args_info->block_bits_given)
	{
		fprintf (stderr, "%s: '--block-bits' ('-b') option required%s\n", prog_name, (additional_error ? additional_error : ""));
		error_occurred = 1;
	}


	/* checks for dependences among options */

	return error_occurred;
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
 * @param override @see cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
			   unsigned int *field_given, unsigned int *prev_given,
			   char *value, const char *possible_values[],
			   const char *default_value,
			   cmdline_parser_arg_type arg_type,
			   int check_ambiguity, int override,
			   int no_free, int multiple_option,
			   const char *long_opt, char short_opt,
			   const char *additional_error)
{
	char *stop_char = 0;
	const char *val = value;
	int found;
	char **string_field;
	FIX_UNUSED (field);

	stop_char = 0;
	found = 0;

	if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
	{
		if (short_opt != '-')
			fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n",
					 package_name, long_opt, short_opt,
					 (additional_error ? additional_error : ""));
		else
			fprintf (stderr, "%s: `--%s' option given more than once%s\n",
					 package_name, long_opt,
					 (additional_error ? additional_error : ""));
		return 1; /* failure */
	}

	FIX_UNUSED (default_value);

	if (field_given && *field_given && ! override)
		return 0;
	if (prev_given)
		(*prev_given)++;
	if (field_given)
		(*field_given)++;
	if (possible_values)
		val = possible_values[found];

	switch(arg_type) {
		case ARG_INT:
			if (val) *((int *)field) = strtol (val, &stop_char, 0);
			break;
		case ARG_STRING:
			if (val) {
				string_field = (char **)field;
				if (!no_free && *string_field)
					free (*string_field); /* free previous string */
				*string_field = gengetopt_strdup (val);
			}
			break;
		default:
			break;
	};

	/* check numeric conversion */
	switch(arg_type) {
		case ARG_INT:
			if (val && !(stop_char && *stop_char == '\0')) {
				fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
				return 1; /* failure */
			}
			break;
		default:
			;
	};

	/* store the original value */
	switch(arg_type) {
		case ARG_NO:
			break;
		default:
			if (value && orig_field) {
				if (no_free) {
					*orig_field = value;
				} else {
					if (*orig_field)
						free (*orig_field); /* free previous string */
					*orig_field = gengetopt_strdup (value);
				}
			}
	};

	return 0; /* OK */
}


int
cmdline_parser_internal (
		int argc, char **argv, struct gengetopt_args_info *args_info,
		struct cmdline_parser_params *params, const char *additional_error)
{
	int c;	/* Character of the parsed option.  */

	int error_occurred = 0;
	struct gengetopt_args_info local_args_info;

	int override;
	int initialize;
	int check_required;
	int check_ambiguity;

	package_name = argv[0];

	override = params->override;
	initialize = params->initialize;
	check_required = params->check_required;
	check_ambiguity = params->check_ambiguity;

	if (initialize)
		cmdline_parser_init (args_info);

	cmdline_parser_init (&local_args_info);

	optarg = 0;
	optind = 0;
	opterr = params->print_errors;
	optopt = '?';

	while (1)
	{
		int option_index = 0;

		static struct option long_options[] = {
				{ "help",	0, NULL, 'h' },
				{ "detailed-help",	0, NULL, 0 },
				{ "version",	0, NULL, 'V' },
				{ "verbose",	0, NULL, 'v' },
				{ "set-index-bits",	1, NULL, 's' },
				{ "associativity",	1, NULL, 'E' },
				{ "block-bits",	1, NULL, 'b' },
				{ "tracefile",	1, NULL, 't' },
				{ 0,  0, 0, 0 }
		};

		c = getopt_long (argc, argv, "hVvs:E:b:t:", long_options, &option_index);

		if (c == -1) break;	/* Exit from `while (1)' loop.  */

		switch (c)
		{
			case 'h':	/* Print help and exit.  */
				cmdline_parser_print_help ();
				cmdline_parser_free (&local_args_info);
				exit (EXIT_SUCCESS);

			case 'V':	/* Print version and exit.  */
				cmdline_parser_print_version ();
				cmdline_parser_free (&local_args_info);
				exit (EXIT_SUCCESS);

			case 'v':	/* Print trace info.  */


				if (update_arg( 0 ,
								0 , &(args_info->verbose_given),
								&(local_args_info.verbose_given), optarg, 0, 0, ARG_NO,
								check_ambiguity, override, 0, 0,
								"verbose", 'v',
								additional_error))
					goto failure;

				break;
			case 's':	/* Number of set index bits.  */


				if (update_arg( (void *)&(args_info->set_index_bits_arg),
								&(args_info->set_index_bits_orig), &(args_info->set_index_bits_given),
								&(local_args_info.set_index_bits_given), optarg, 0, 0, ARG_INT,
								check_ambiguity, override, 0, 0,
								"set-index-bits", 's',
								additional_error))
					goto failure;

				break;
			case 'E':	/* Number of lines per set.  */


				if (update_arg( (void *)&(args_info->associativity_arg),
								&(args_info->associativity_orig), &(args_info->associativity_given),
								&(local_args_info.associativity_given), optarg, 0, 0, ARG_INT,
								check_ambiguity, override, 0, 0,
								"associativity", 'E',
								additional_error))
					goto failure;

				break;
			case 'b':	/* Number of block bits.  */


				if (update_arg( (void *)&(args_info->block_bits_arg),
								&(args_info->block_bits_orig), &(args_info->block_bits_given),
								&(local_args_info.block_bits_given), optarg, 0, 0, ARG_INT,
								check_ambiguity, override, 0, 0,
								"block-bits", 'b',
								additional_error))
					goto failure;

				break;
			case 't':	/* Tracefile as generated by valgrind.  */


				if (update_arg( (void *)&(args_info->tracefile_arg),
								&(args_info->tracefile_orig), &(args_info->tracefile_given),
								&(local_args_info.tracefile_given), optarg, 0, 0, ARG_STRING,
								check_ambiguity, override, 0, 0,
								"tracefile", 't',
								additional_error))
					goto failure;

				break;

			case 0:	/* Long option with no short option */
				if (strcmp (long_options[option_index].name, "detailed-help") == 0) {
					cmdline_parser_print_detailed_help ();
					cmdline_parser_free (&local_args_info);
					exit (EXIT_SUCCESS);
				}

			case '?':	/* Invalid option.  */
				/* `getopt_long' already printed an error message.  */
				goto failure;

			default:	/* bug: option not considered.  */
				fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
				abort ();
		} /* switch */
	} /* while */



	if (check_required)
	{
		error_occurred += cmdline_parser_required2 (args_info, argv[0], additional_error);
	}

	cmdline_parser_release (&local_args_info);

	if ( error_occurred )
		return (EXIT_FAILURE);

	return 0;

	failure:

	cmdline_parser_release (&local_args_info);
	return (EXIT_FAILURE);
}


const size_t INPUT_BUF_SIZE = 1024;

/*
 * @**********************@
 * CRMYERS CODE BEGINS HERE
 * @**********************@
 */

/**
 * A single line in a CacheLine. Contains a pointer to the next CacheLine in series -- LRU is implemented using a doubly
 * linked list. The item at the end is the least-recently used cache line. The list can be at most args.associativity_arg
 * size, anything beyond that and we'll start evicting entries.
 */
struct cacheLine {
	uint64_t tag;
	struct cacheLine* next;
	struct cacheLine* prev;
};
typedef struct cacheLine CacheLine;

typedef struct {
	CacheLine* cacheLines;
	uint16_t size;
} CacheSet;

//Store a line in the cache. Returns non-zero if an eviction was made, else returns 0.
int storeLine(uint64_t addr, CacheSet* set, const int ASSOC, const uint64_t TAG_MASK);

//Recursively free a cache line's memory. Only used for the shutdown sequence.
void freeCacheLine(CacheLine* target);

int main(int argc, char** argv)
{
    struct gengetopt_args_info args;
	cmdline_parser(argc, argv, &args);

	FILE* tracefile = stdin; //If we don't receive a tracefile, just read from stdin. This allows user interactivity!
	if (args.tracefile_given && (tracefile = fopen(args.tracefile_arg, "r")) == NULL){
		perror("Couldn't access tracefile");
		abort();
	}

	//Now that the setup work is all done, let's do some some cache simulation work!
	int cacheHits = 0, cacheMisses = 0, cacheEvictions = 0;
	const int CACHE_SETS = 1 << args.set_index_bits_arg;
	const uint64_t BLOCK_MASK = (const unsigned int)(1 << args.block_bits_arg) - 1;
	const uint64_t SET_MASK = ((1 << (args.set_index_bits_arg + args.block_bits_arg )) - 1) ^ BLOCK_MASK;
	const uint64_t TAG_MASK = ~(BLOCK_MASK | SET_MASK);
	char* inputBuf = (char*)malloc(INPUT_BUF_SIZE);
	CacheSet* cache = (CacheSet*)malloc(sizeof(CacheSet) * CACHE_SETS);

	//Input loop; read a line, check if the first character is 'I'. If so, discard it (we don't care about instruction
	//loads). Else, process it according to whether it's a load (L), store (S), or modify (M). After the memory access
	//type, the first number is hex for the address accessed while the second is a number indicating the amount accessed.
	while (1){
		memset(inputBuf, 0, INPUT_BUF_SIZE);
		if (fgets(inputBuf, INPUT_BUF_SIZE, tracefile) == NULL)
			break; //EOF or some error condition

		if (inputBuf[0] == 'I')
			continue;

		char operator = 'L';
		uint64_t addr = 0, size = 0;
		sscanf(inputBuf, " %c %lx,%lu", &operator, &addr, &size);

		//First step: Figure out what set we're supposed to be looking at. The set bits are in between the tag bits and
		//the block offset bits, so we need to form a mask out of them.
		uint64_t setNum = (addr & SET_MASK) >> args.block_bits_arg;
		CacheSet* selectedSet = &cache[setNum];

		//Cache set grabbed, now search through its cache lines to find a matching tag (if one exists).
		if (args.verbose_given)
			printf("%c %lx,%lu ", operator, addr, size);
		for (CacheLine* cur = selectedSet->cacheLines;; cur = cur->next){
			if (cur == NULL){
				//Store a line in the cache, incrementing the eviction count if needed. If the op was a modify call,
				//increase the hit counter by one (modfy = R+W).
				if (args.verbose_given)
					printf("miss ");
				cacheMisses++;
				if (storeLine(addr, selectedSet, args.associativity_arg, TAG_MASK)){
					cacheEvictions++;
					if (args.verbose_given)
						printf("eviction ");
				}
				if (operator == 'M'){
					cacheHits++;
					if (args.verbose_given)
						printf("hit ");
				}
				break;
			}

			if (cur->tag == (addr & TAG_MASK)){
				cacheHits++;
				if (operator == 'M') {
					cacheHits++;
					if (args.verbose_given)
						printf("hit ");
				}

				//Move curr up in life, if needed
				if (cur != selectedSet->cacheLines) {
					if (cur->prev != NULL)
						cur->prev->next = cur->next;
					if (cur->next != NULL)
						cur->next->prev = cur->prev;
					selectedSet->cacheLines->prev = cur;
					cur->next = selectedSet->cacheLines;
					cur->prev = NULL;
					selectedSet->cacheLines = cur;
				}

				if (args.verbose_given)
					printf("hit ");
				break;
			}
		}
		if (args.verbose_given)
			printf("\n");
	}

	//Free all memory, print the summary, and shut down
	free(inputBuf);
	for (int i = 0; i < args.associativity_arg; i++)
		freeCacheLine(cache[i].cacheLines);
	free(cache);
    printSummary(cacheHits, cacheMisses, cacheEvictions);
    return 0;
}

int storeLine(uint64_t addr, CacheSet* set, const int ASSOC, const uint64_t TAG_MASK){
	//Check the number of lines stored in the set; if equal to ASSOC, we need to evict. In the happy case where there
	//are no evictions, just append to the end of the list.
	CacheLine* newLine = (CacheLine*)malloc(sizeof(CacheLine));
	newLine->tag = addr & TAG_MASK;
	CacheLine* last = set->cacheLines;
	for (CacheLine* cur = set->cacheLines; cur != NULL; cur = cur->next){
		if (cur->next == NULL) {
			last = cur;
			break;
		}
	}

	if (set->size < ASSOC){
		if (last == NULL) //that was easy
			set->cacheLines = newLine;
		else {
			set->cacheLines->prev = newLine;
			newLine->next = set->cacheLines;
			set->cacheLines = newLine;
		}
		set->size++;
		return 0;
	}
	else {
		//Serve eviction notice and change out the locks
		if (ASSOC > 1) {
			last->prev->next = NULL;
			free(last);
			newLine->next = set->cacheLines;
			set->cacheLines->prev = newLine;
		}
		set->cacheLines = newLine;
		return 1;
	}
}

void freeCacheLine(CacheLine* target){
	if (target == NULL)
		return;
	if (target->next != NULL)
		freeCacheLine(target->next);
	free(target);
}
